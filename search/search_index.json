{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"WarpSTR \u00b6 WarpSTR is an alignment-free algorithm for analysing STR alleles using nanopore sequencing raw reads. The method uses guppy basecalling annotation output for the extraction of region of interest, and dynamic time warping based state automata for calling raw signal data. The tool can be configured to account for complex motifs containing interruptions and other variations such as substitutions or ambiguous bases. See our preprint at: https://www.biorxiv.org/content/10.1101/2022.11.05.515275v1 Documentation overview \u00b6 See Installation chapter for information about how to install WarpSTR. To know more about how to setup the configuration file, see Setting up the config and Advanced parameters . Before running WarpSTR, ensure that input files are located accordingly as set up in the config file. To know more about output files and what they represent, see Output chapter . Question If you have any questions, problems or ideas, please raise an issue on Github or write an email to jozefsitarcik@uniba.sk and we will look further into it as soon as possible.","title":"Home"},{"location":"#warpstr","text":"WarpSTR is an alignment-free algorithm for analysing STR alleles using nanopore sequencing raw reads. The method uses guppy basecalling annotation output for the extraction of region of interest, and dynamic time warping based state automata for calling raw signal data. The tool can be configured to account for complex motifs containing interruptions and other variations such as substitutions or ambiguous bases. See our preprint at: https://www.biorxiv.org/content/10.1101/2022.11.05.515275v1","title":"WarpSTR"},{"location":"#documentation-overview","text":"See Installation chapter for information about how to install WarpSTR. To know more about how to setup the configuration file, see Setting up the config and Advanced parameters . Before running WarpSTR, ensure that input files are located accordingly as set up in the config file. To know more about output files and what they represent, see Output chapter . Question If you have any questions, problems or ideas, please raise an issue on Github or write an email to jozefsitarcik@uniba.sk and we will look further into it as soon as possible.","title":"Documentation overview"},{"location":"advanced_params/","text":"Advanced parameters \u00b6 Many parameters can be set in addition to the parameters mentioned in the Config section . The list of all parameters with their default values is in the repository example/advanced_params.yaml . To change values for those parameters, simply add those parameters to your main config and set them to the desired value. Else, default values for those parameters are used. Further below, we describe some of these parameters from the use case point of view. Using multiple threads \u00b6 Add threads field and provide the desired value: threads : 32 Note Multiple threads are used for tr_region_extraction and tr_region_calling steps. Using nanopore data different from R9.4 \u00b6 WarpSTR by default uses the template pore model for the R9.4 chemistry. In other cases, such as as using R10 chemistry or other, you must provide the corresponding pore model (with expected signal values for all possible kmers) by path: pore_model_path : template_r10.model Warning Different pore models are supported but they were not tested whether they produce satisfactory results. Changing hyperparameters for tandem repeat calling \u00b6 WarpSTR offers the following parameters: spike_removal - Possible values are None - no removal, median3 and median5 for median filtering window size of 3 and 5, respectively, and Brute for median filtering of window 5, but only for outliers, where outliers are determined as signal values not between 250 and 1000. Spike removal occur before normalization. Default: Brute min_values_per_state - defines the minimum number of signal values required to map to one state. Default: 4. This is not recommended to change. states_in_segment - defines the number of states that are contained in one window during the adaptive relaxation phase. Default 6. Lower values are less robust. min_state_similarity - defines the minimum similarity between repeat states to raise a warning. Default: 0.75. All these parameters are subfields of tr_calling_config field. Further you can modify rescaling (polishing) hyperparameters: reps_as_one - defines whether to merge all signal points of the repeating state together or not for the polishing phase. Default: False. threshold - Max distance between state value and expected value to use the state for rescaling. Default: 0.5. Larger values mean that incorrectly aligned state (as the distance is larger) is used to rescale the data, which can results in less accurate rescaling. max_std - Max standard deviation for signal points of the state to use that state for rescaling. Default: 0.5. Larger values mean that incorrectly aligned state (as the standard deviation is larger meaning it is too noisy) is used to rescale the data, which can results in less accurate rescaling. method - Defines how to calculate state value from mapped signal points. Allowed mean and median . For example, to change spike_removal to median3 and rescaling hyperparameter threshold to 1, provide the following in your config: tr_calling_config : spike_removal : median3 rescaling : threshold : 1 Further, you can turn off some visualizations (see Output chapter ) by extending the tr_calling_config : tr_calling_config : spike_removal : median3 visualize_alignment : False # signal alignments visualize_phase : False # allele lengths split per phase visualize_strand : False # allele lengths split per strand visualize_cost : False # scatterplot of lengths vs state-wise cost rescaling : threshold : 1 Changing hyperparameters for summarizing \u00b6 For the summarizing step of WarpSTR, the following parameters can be modified: min_weight - Defines the minimum weight for heterozygosity. When one mixture model component has lower weight than this, the allele is declared as homozygous. Default: 0.2. Lower values mean that it is more probable to take a low frequency component as allele. std_filter - Defines the aggressiveness for filtering out predictions. Predictions are filtered if they are out of range: mean +- 2*std_filter. Default: 2. Higher values mean more aggressive filtering. visualize - Whether to output violinplot of clusters (see see Output chapter ). msa - Whether to run muscle to get multiple sequence alignment of predictions and basecalls. Default: False To increase the aggressiveness of filtering, we can increase the std_filter hyperparameter as follows: genotyping_config : std_filter : 2.5 Changing hyperparameters for alignment \u00b6 For the tr_extraction step, we can modify the parameters for local alignment of flanks with the basecalled sequence. The optional parameters are: accuracy_factor - Defines whether the alignment score is good enough. A flank is deemed as not found when the ratio of its alignment score and the length is lower than this value. Default: 1.15. The value depends extremely on the scoring parameters. identity_factor - Defines whether the alignment score is good enough. A flank is deemed as not found when its alignment has lower identity than this, i.e. number of matches compared to the length. Default: 0.85. The value depends extremely on the scoring parameters. match_score - Defines how much is added to the alignment score when nucleotides match. Default: 2. Should be a positive value. mismatch_score - Defines how much is added to the alignment score when nucleotides do not match. Default: -3. Should be a negative value or smaller than match_score . gap_open_score - Defines how much is added to the alignment score when a gap is opened. Default: -3. Should be a negative value. gap_extend_score - Defines how much is added to the alignment score when a gap is extended. Default: -3. Should be a negative value smaller or equal to gap_open_score . To change these parameters, we recommend to change all parameters at once, as they are strong dependencies. The example of change: alignment : accuracy_factor : 1.15 identity_factor : 0.85 match_score : 2 mismatch_score : -3 gap_open_score : -3 gap_extend_score : -3 Warning These settings strongly influences whether the repeat signal would be localized correctly and whether the read would be used for subsequent repeat number characterization.","title":"Advanced parameters"},{"location":"advanced_params/#advanced-parameters","text":"Many parameters can be set in addition to the parameters mentioned in the Config section . The list of all parameters with their default values is in the repository example/advanced_params.yaml . To change values for those parameters, simply add those parameters to your main config and set them to the desired value. Else, default values for those parameters are used. Further below, we describe some of these parameters from the use case point of view.","title":"Advanced parameters"},{"location":"advanced_params/#using-multiple-threads","text":"Add threads field and provide the desired value: threads : 32 Note Multiple threads are used for tr_region_extraction and tr_region_calling steps.","title":"Using multiple threads"},{"location":"advanced_params/#using-nanopore-data-different-from-r94","text":"WarpSTR by default uses the template pore model for the R9.4 chemistry. In other cases, such as as using R10 chemistry or other, you must provide the corresponding pore model (with expected signal values for all possible kmers) by path: pore_model_path : template_r10.model Warning Different pore models are supported but they were not tested whether they produce satisfactory results.","title":"Using nanopore data different from R9.4"},{"location":"advanced_params/#changing-hyperparameters-for-tandem-repeat-calling","text":"WarpSTR offers the following parameters: spike_removal - Possible values are None - no removal, median3 and median5 for median filtering window size of 3 and 5, respectively, and Brute for median filtering of window 5, but only for outliers, where outliers are determined as signal values not between 250 and 1000. Spike removal occur before normalization. Default: Brute min_values_per_state - defines the minimum number of signal values required to map to one state. Default: 4. This is not recommended to change. states_in_segment - defines the number of states that are contained in one window during the adaptive relaxation phase. Default 6. Lower values are less robust. min_state_similarity - defines the minimum similarity between repeat states to raise a warning. Default: 0.75. All these parameters are subfields of tr_calling_config field. Further you can modify rescaling (polishing) hyperparameters: reps_as_one - defines whether to merge all signal points of the repeating state together or not for the polishing phase. Default: False. threshold - Max distance between state value and expected value to use the state for rescaling. Default: 0.5. Larger values mean that incorrectly aligned state (as the distance is larger) is used to rescale the data, which can results in less accurate rescaling. max_std - Max standard deviation for signal points of the state to use that state for rescaling. Default: 0.5. Larger values mean that incorrectly aligned state (as the standard deviation is larger meaning it is too noisy) is used to rescale the data, which can results in less accurate rescaling. method - Defines how to calculate state value from mapped signal points. Allowed mean and median . For example, to change spike_removal to median3 and rescaling hyperparameter threshold to 1, provide the following in your config: tr_calling_config : spike_removal : median3 rescaling : threshold : 1 Further, you can turn off some visualizations (see Output chapter ) by extending the tr_calling_config : tr_calling_config : spike_removal : median3 visualize_alignment : False # signal alignments visualize_phase : False # allele lengths split per phase visualize_strand : False # allele lengths split per strand visualize_cost : False # scatterplot of lengths vs state-wise cost rescaling : threshold : 1","title":"Changing hyperparameters for tandem repeat calling"},{"location":"advanced_params/#changing-hyperparameters-for-summarizing","text":"For the summarizing step of WarpSTR, the following parameters can be modified: min_weight - Defines the minimum weight for heterozygosity. When one mixture model component has lower weight than this, the allele is declared as homozygous. Default: 0.2. Lower values mean that it is more probable to take a low frequency component as allele. std_filter - Defines the aggressiveness for filtering out predictions. Predictions are filtered if they are out of range: mean +- 2*std_filter. Default: 2. Higher values mean more aggressive filtering. visualize - Whether to output violinplot of clusters (see see Output chapter ). msa - Whether to run muscle to get multiple sequence alignment of predictions and basecalls. Default: False To increase the aggressiveness of filtering, we can increase the std_filter hyperparameter as follows: genotyping_config : std_filter : 2.5","title":"Changing hyperparameters for summarizing"},{"location":"advanced_params/#changing-hyperparameters-for-alignment","text":"For the tr_extraction step, we can modify the parameters for local alignment of flanks with the basecalled sequence. The optional parameters are: accuracy_factor - Defines whether the alignment score is good enough. A flank is deemed as not found when the ratio of its alignment score and the length is lower than this value. Default: 1.15. The value depends extremely on the scoring parameters. identity_factor - Defines whether the alignment score is good enough. A flank is deemed as not found when its alignment has lower identity than this, i.e. number of matches compared to the length. Default: 0.85. The value depends extremely on the scoring parameters. match_score - Defines how much is added to the alignment score when nucleotides match. Default: 2. Should be a positive value. mismatch_score - Defines how much is added to the alignment score when nucleotides do not match. Default: -3. Should be a negative value or smaller than match_score . gap_open_score - Defines how much is added to the alignment score when a gap is opened. Default: -3. Should be a negative value. gap_extend_score - Defines how much is added to the alignment score when a gap is extended. Default: -3. Should be a negative value smaller or equal to gap_open_score . To change these parameters, we recommend to change all parameters at once, as they are strong dependencies. The example of change: alignment : accuracy_factor : 1.15 identity_factor : 0.85 match_score : 2 mismatch_score : -3 gap_open_score : -3 gap_extend_score : -3 Warning These settings strongly influences whether the repeat signal would be localized correctly and whether the read would be used for subsequent repeat number characterization.","title":"Changing hyperparameters for alignment"},{"location":"config/","text":"Configuration file \u00b6 The only required parameter for running WarpSTR is the path to the config file. The file must be in YAML format. It must be populated with elements such as inputs , output and reference_path . An example is provided in example/config.yaml . There are also many advanced parameters that are optional to set. List of all parameters are found in example/advanced_params.yaml . To set values for those parameters, just add those parameters to your main config and set them to the desired value. In other case, default values for those parameters are taken. Description of required parameters \u00b6 Fields of the configuration file are described concisely in comments, here some of them are described more thoroughly. Input \u00b6 Required input data are .fast5 files and .bam mapping files. In configuration file, the user is required to provide the path to the upper level path, in the inputs element. WarpSTR presumes that your data can come from multiple sequencing runs, but are of the same sample, and thus are to be analyzed together. For example, you have main directory for sample subjectXY with many subdirectories denoting sequencing runs i.e. run_1 , run_2 , with each run directory having its own .bam mapping file and .fast5 files. It is also possible to denote another path to input, in case of having data stored somewhere else (i.e. on the other mounted directory, as ONT data are very large), for example with the data from another run, i.e. run_3 . For the above example, inputs in the config could be defined as follows: inputs : - path : /data/subjectXY runs : run_1,run_2 - path : /mnt/subjectXY runs : run_3 Each directory as given by path and runs , i.e. /data/subjectXY/run_1 and so on, is traversed by WarpSTR to find .bam files and .fast5 files. Tip See Test case for an example of test data and associated config. Reference path \u00b6 Path to the reference fasta file. The reference is required for two things: in the exp_signal_generation step. Here the reference is used to extract flanking sequences of the locus. when sequence field is missing in locus configuration. Here, the reference is used to obtain the reference locus sequence and to automatically generate sequence field required for subsequent steps. In other cases (skipping exp_signal_generation step and supplying sequence for all loci), the reference path is not needed. guppy_config \u00b6 This field is a list, such as: guppy_config : path : guppy_executable flowcell : FLO-MIN106 kit : SQK-LSK109 In path subfield supply the path to the executable guppy basecaller, and in flowcell and kit provide the nanopore sequencing information for the data. This field must be filled in case of running step guppy_annotation , where input .fast5 files are basecalled (or basecalled again) to obtain the mapping between the basecalled sequence and the signal data. Loci information \u00b6 Information about loci, that are subjects for analysis by WarpSTR, must be described in the config file. An example is described example/config.yaml : Each locus has the following information: name - denotes the name of the output subdirectory for this locus. coord - genomic coordinates of the locus. motif - used to obtain the sequence for automaton automatically. Should be a pattern or a comma separated list of patterns such as AGC,CGC , that are presumed to repeat in the locus. This parameter is recommended for beginners or for initial analysis of the locus. For advanced usage see sequence field. sequence - used for constructing state automaton directly (flanks are automatically added accordingly). Supplying a better tailored sequence in this field produces usually more accurate results. See Setting up automaton sequence for more information. Warning - motif field is ignored if using sequence . noting - currently not used, serves only as some kind of note. flank_length - It denotes how many nucleotides are taken from the reference as flanks. If not set, the default value of 110 is used. An example for Huntington's disease locus: name : HD coord : chr4:3,074,878-3,074,967 noting : AGC[19]AAC[1]AGC[1]CGC[1]CAC[1]CGC[7] motif : AGC,CGC # use this sequence : (AGC)AACAGCCGCCAC(CGC) # or this Automaton sequence \u00b6 The sequence for automaton is a concatenated string of three substrings: left flank, repeat sequence and right flank. All sequences are taken from the reference, but the repeat sequence can be set manually, mainly in cases when you presume that there are differences between the reference locus and your subject locus such as mutations in the repeating pattern or novel repeating patterns. The repeat sequence has a strict syntax: IUPAC codes - denoting patterns parentheses ( and ) - everything between them is taken as the repeat structure that must occur at least once. curly brackets { and } - everything between them is taken as optional repeat structure that can occur zero times. all substrings that are not inside parentheses or brackets must occur exactly once. For example, (AGC)AACAGCCGCCAC(CGC) , means that there could be 1-N repeats of AGC, followed by nonrepeating part AACAGCCGCCAC, and ending with 1-N repeats of (CGC). It is important to not provide a repeat sequence that is too lenient, i.e. providing many possible states as that would make the aligning very slow and probably not accurate. This is due to the nature of the nanopore sequencing data, as many patterns are too similar to each other and due to noise or time dilation, alignment would not be accurate. For example, you could model (AGC)AACAGCCGCCAC(CGC) with a more lenient version such as (MRC) , where M denotes A or C, and R denotes A or G, but this sequence models a vast amount of other possibilities. Therefore, you should try to set the sequence as strict as possible. Warning Do not use WarpSTR for homopolymeric sequences, i.e. do not set the sequence to contain parts such as (C) .","title":"Config"},{"location":"config/#configuration-file","text":"The only required parameter for running WarpSTR is the path to the config file. The file must be in YAML format. It must be populated with elements such as inputs , output and reference_path . An example is provided in example/config.yaml . There are also many advanced parameters that are optional to set. List of all parameters are found in example/advanced_params.yaml . To set values for those parameters, just add those parameters to your main config and set them to the desired value. In other case, default values for those parameters are taken.","title":"Configuration file"},{"location":"config/#description-of-required-parameters","text":"Fields of the configuration file are described concisely in comments, here some of them are described more thoroughly.","title":"Description of required parameters"},{"location":"config/#input","text":"Required input data are .fast5 files and .bam mapping files. In configuration file, the user is required to provide the path to the upper level path, in the inputs element. WarpSTR presumes that your data can come from multiple sequencing runs, but are of the same sample, and thus are to be analyzed together. For example, you have main directory for sample subjectXY with many subdirectories denoting sequencing runs i.e. run_1 , run_2 , with each run directory having its own .bam mapping file and .fast5 files. It is also possible to denote another path to input, in case of having data stored somewhere else (i.e. on the other mounted directory, as ONT data are very large), for example with the data from another run, i.e. run_3 . For the above example, inputs in the config could be defined as follows: inputs : - path : /data/subjectXY runs : run_1,run_2 - path : /mnt/subjectXY runs : run_3 Each directory as given by path and runs , i.e. /data/subjectXY/run_1 and so on, is traversed by WarpSTR to find .bam files and .fast5 files. Tip See Test case for an example of test data and associated config.","title":"Input"},{"location":"config/#reference-path","text":"Path to the reference fasta file. The reference is required for two things: in the exp_signal_generation step. Here the reference is used to extract flanking sequences of the locus. when sequence field is missing in locus configuration. Here, the reference is used to obtain the reference locus sequence and to automatically generate sequence field required for subsequent steps. In other cases (skipping exp_signal_generation step and supplying sequence for all loci), the reference path is not needed.","title":"Reference path"},{"location":"config/#guppy_config","text":"This field is a list, such as: guppy_config : path : guppy_executable flowcell : FLO-MIN106 kit : SQK-LSK109 In path subfield supply the path to the executable guppy basecaller, and in flowcell and kit provide the nanopore sequencing information for the data. This field must be filled in case of running step guppy_annotation , where input .fast5 files are basecalled (or basecalled again) to obtain the mapping between the basecalled sequence and the signal data.","title":"guppy_config"},{"location":"config/#loci-information","text":"Information about loci, that are subjects for analysis by WarpSTR, must be described in the config file. An example is described example/config.yaml : Each locus has the following information: name - denotes the name of the output subdirectory for this locus. coord - genomic coordinates of the locus. motif - used to obtain the sequence for automaton automatically. Should be a pattern or a comma separated list of patterns such as AGC,CGC , that are presumed to repeat in the locus. This parameter is recommended for beginners or for initial analysis of the locus. For advanced usage see sequence field. sequence - used for constructing state automaton directly (flanks are automatically added accordingly). Supplying a better tailored sequence in this field produces usually more accurate results. See Setting up automaton sequence for more information. Warning - motif field is ignored if using sequence . noting - currently not used, serves only as some kind of note. flank_length - It denotes how many nucleotides are taken from the reference as flanks. If not set, the default value of 110 is used. An example for Huntington's disease locus: name : HD coord : chr4:3,074,878-3,074,967 noting : AGC[19]AAC[1]AGC[1]CGC[1]CAC[1]CGC[7] motif : AGC,CGC # use this sequence : (AGC)AACAGCCGCCAC(CGC) # or this","title":"Loci information"},{"location":"config/#automaton-sequence","text":"The sequence for automaton is a concatenated string of three substrings: left flank, repeat sequence and right flank. All sequences are taken from the reference, but the repeat sequence can be set manually, mainly in cases when you presume that there are differences between the reference locus and your subject locus such as mutations in the repeating pattern or novel repeating patterns. The repeat sequence has a strict syntax: IUPAC codes - denoting patterns parentheses ( and ) - everything between them is taken as the repeat structure that must occur at least once. curly brackets { and } - everything between them is taken as optional repeat structure that can occur zero times. all substrings that are not inside parentheses or brackets must occur exactly once. For example, (AGC)AACAGCCGCCAC(CGC) , means that there could be 1-N repeats of AGC, followed by nonrepeating part AACAGCCGCCAC, and ending with 1-N repeats of (CGC). It is important to not provide a repeat sequence that is too lenient, i.e. providing many possible states as that would make the aligning very slow and probably not accurate. This is due to the nature of the nanopore sequencing data, as many patterns are too similar to each other and due to noise or time dilation, alignment would not be accurate. For example, you could model (AGC)AACAGCCGCCAC(CGC) with a more lenient version such as (MRC) , where M denotes A or C, and R denotes A or G, but this sequence models a vast amount of other possibilities. Therefore, you should try to set the sequence as strict as possible. Warning Do not use WarpSTR for homopolymeric sequences, i.e. do not set the sequence to contain parts such as (C) .","title":"Automaton sequence"},{"location":"installation/","text":"Installation \u00b6 First, clone the repository: git clone git@github.com:fmfi-compbio/warpstr.git WarpSTR can then be easily installed using the conda environment, frozen in conda_req.yaml . The conda environment can be created as follows: conda env create -f conda_req.yaml After installation, it is required to activate conda environment: conda activate warpstr WarpSTR was tested in Ubuntu 20.04 OS. If you have any problems with installation, please raise an issue on Github and we will look further into it as soon as possible. Test case \u00b6 In test/test_input there is a small test dataset. There are 10 reads for one locus. In the template config test/config_template.yaml you can see that inputs are defined as follows: inputs : - path : test/test_input runs : test_run1 In the test data, there is only one run, called test_run1 with all sequencing files stored there (i.e. BAM files and .fast5 files): test_input/ \u2514\u2500\u2500 test_run1 \u251c\u2500\u2500 fast5s \u2502 \u2514\u2500\u2500 batch_0.fast5 \u2514\u2500\u2500 mapping \u251c\u2500\u2500 mapping.bam \u2514\u2500\u2500 mapping.bam.bai Note In WarpSTR, we allow for multiple sequencing runs, which are defined by runs element, where other runs are defined by comma, i.e. test_run1,test_run2 and so on. WarpSTR concatenates path value with each comma splitted value of runs to obtain a list of paths, that are then search recursively for input files (.BAM and .fast5 files). To run test data, you need to define reference_path and guppy_config.path in the config, or you can use provided wrapper bash script run_test_case.sh . Simply, when in WarpSTR directory (and with activated conda environment), run the wrapper script: bash run_test_case.sh When running this wrapper script, the script will prompt you to provide the required paths and run the WarpSTR for you. Output files will be then stored in test/test_output/ as given in the config file. Warning Test data were produced using human genome reference denoted as GRCh38 , so ensure that you provide the path to the refernce of this version. You can download the reference for example from https://www.ncbi.nlm.nih.gov/assembly/GCF_000001405.26/","title":"Install"},{"location":"installation/#installation","text":"First, clone the repository: git clone git@github.com:fmfi-compbio/warpstr.git WarpSTR can then be easily installed using the conda environment, frozen in conda_req.yaml . The conda environment can be created as follows: conda env create -f conda_req.yaml After installation, it is required to activate conda environment: conda activate warpstr WarpSTR was tested in Ubuntu 20.04 OS. If you have any problems with installation, please raise an issue on Github and we will look further into it as soon as possible.","title":"Installation"},{"location":"installation/#test-case","text":"In test/test_input there is a small test dataset. There are 10 reads for one locus. In the template config test/config_template.yaml you can see that inputs are defined as follows: inputs : - path : test/test_input runs : test_run1 In the test data, there is only one run, called test_run1 with all sequencing files stored there (i.e. BAM files and .fast5 files): test_input/ \u2514\u2500\u2500 test_run1 \u251c\u2500\u2500 fast5s \u2502 \u2514\u2500\u2500 batch_0.fast5 \u2514\u2500\u2500 mapping \u251c\u2500\u2500 mapping.bam \u2514\u2500\u2500 mapping.bam.bai Note In WarpSTR, we allow for multiple sequencing runs, which are defined by runs element, where other runs are defined by comma, i.e. test_run1,test_run2 and so on. WarpSTR concatenates path value with each comma splitted value of runs to obtain a list of paths, that are then search recursively for input files (.BAM and .fast5 files). To run test data, you need to define reference_path and guppy_config.path in the config, or you can use provided wrapper bash script run_test_case.sh . Simply, when in WarpSTR directory (and with activated conda environment), run the wrapper script: bash run_test_case.sh When running this wrapper script, the script will prompt you to provide the required paths and run the WarpSTR for you. Output files will be then stored in test/test_output/ as given in the config file. Warning Test data were produced using human genome reference denoted as GRCh38 , so ensure that you provide the path to the refernce of this version. You can download the reference for example from https://www.ncbi.nlm.nih.gov/assembly/GCF_000001405.26/","title":"Test case"},{"location":"output/","text":"Output \u00b6 The upper path for output is given in the .yaml configuration file as output element. Outputs are separated for each locus as subdirectories of this upper path, where names of subdirectories are the same as the locus name. The output structure for one locus is as follows: alignments/ # contains alignments of template flanks with reads expected_signals/ # contains template flanks as sequences and expected signals fast5/ # signals extracted as encompasssing the locus, stored as signle .fast5 files predictions/ # contains visualizations of automaton alignments and basecalled sequences (see below) summaries/ # contains visualizations produced in the last summarizing phase (see below) overview.csv # .csv file with read information and output Some output files are optional and can be controlled by the .yaml config file. Predictions \u00b6 In the predictions directory of each locus there would be a large variety of outputted files in other subdirectories. In basecalls subdirectory are output files related to basecalling, such as all.fasta containing basecalled sequences of all reads encompassing the locus as given by SAM/BAM, basecalls_all.fasta containing only reads in which flanks were found. This file is further split per strand into basecalls_reverse.fasta and basecalls_template.fasta . In case of running muscle for MSA - multiple sequence alignment (controlled by advanced_params config), there would be msa_all.fasta file with MSA. In case of running summarizing, there would be group1.fasta and group2.fasta files where would be basecalled sequences split into groups as summarized by the last step of WarpSTR. In such case MSA output would be also created only for basecalled sequences of each group. In complex_repeat_units.csv file there is counter for each repeat structure of the complex STR locus. Each row denote a read, and in columns are counts for repeat structures. In sequences subdirectory there is analogous information as in basecalls subdirectory, but the information is not produced from the basecalled sequences but from sequences as given by WarpSTR. In DTW_alignments subdirectory there are visualized alignments of STR signal with automaton (in both stages). Visualizations are truncated to first 2000 values. Summaries \u00b6 In the summaries directory of each locus there is a myriad of optional visualizations: alleles.svg - Summarized predictions of repeat lengths in 1 or 2 groups and for WarpSTR and basecall. collapsed_predictions.svg - Complex repeat structure counts, only for WarpSTR. collapsed_predictions_strand.svg - As above, but further split by strand. complex_genotypes.svg - Summarized complex repeat structure counts in 1 or 2 groups. predictions_cost.svg - Scatterplot of state-wise cost and allele lengths. predictions_phase.svg - Violinplots of repeat lengths in the first and second phase. predictions_strand.svg - Violinplots of repeat lengths as split by strand.","title":"Output"},{"location":"output/#output","text":"The upper path for output is given in the .yaml configuration file as output element. Outputs are separated for each locus as subdirectories of this upper path, where names of subdirectories are the same as the locus name. The output structure for one locus is as follows: alignments/ # contains alignments of template flanks with reads expected_signals/ # contains template flanks as sequences and expected signals fast5/ # signals extracted as encompasssing the locus, stored as signle .fast5 files predictions/ # contains visualizations of automaton alignments and basecalled sequences (see below) summaries/ # contains visualizations produced in the last summarizing phase (see below) overview.csv # .csv file with read information and output Some output files are optional and can be controlled by the .yaml config file.","title":"Output"},{"location":"output/#predictions","text":"In the predictions directory of each locus there would be a large variety of outputted files in other subdirectories. In basecalls subdirectory are output files related to basecalling, such as all.fasta containing basecalled sequences of all reads encompassing the locus as given by SAM/BAM, basecalls_all.fasta containing only reads in which flanks were found. This file is further split per strand into basecalls_reverse.fasta and basecalls_template.fasta . In case of running muscle for MSA - multiple sequence alignment (controlled by advanced_params config), there would be msa_all.fasta file with MSA. In case of running summarizing, there would be group1.fasta and group2.fasta files where would be basecalled sequences split into groups as summarized by the last step of WarpSTR. In such case MSA output would be also created only for basecalled sequences of each group. In complex_repeat_units.csv file there is counter for each repeat structure of the complex STR locus. Each row denote a read, and in columns are counts for repeat structures. In sequences subdirectory there is analogous information as in basecalls subdirectory, but the information is not produced from the basecalled sequences but from sequences as given by WarpSTR. In DTW_alignments subdirectory there are visualized alignments of STR signal with automaton (in both stages). Visualizations are truncated to first 2000 values.","title":"Predictions"},{"location":"output/#summaries","text":"In the summaries directory of each locus there is a myriad of optional visualizations: alleles.svg - Summarized predictions of repeat lengths in 1 or 2 groups and for WarpSTR and basecall. collapsed_predictions.svg - Complex repeat structure counts, only for WarpSTR. collapsed_predictions_strand.svg - As above, but further split by strand. complex_genotypes.svg - Summarized complex repeat structure counts in 1 or 2 groups. predictions_cost.svg - Scatterplot of state-wise cost and allele lengths. predictions_phase.svg - Violinplots of repeat lengths in the first and second phase. predictions_strand.svg - Violinplots of repeat lengths as split by strand.","title":"Summaries"},{"location":"running_overview/","text":"Running WarpSTR \u00b6 To run WarpSTR, first you must create a configuration file, that must adhere to YAML syntax. Check your input .fast5 and .bam files and populate the config accordingly (See Config section ). Also, you can change some advanced parameters, for that see Advanced parameters section ). Then, running WarpSTR is simple as it requires only the path to the config file. You can run WarpSTR for as many loci as you want, but all the information must be in the config. See example/config.yaml for an example of config file. After populating the config file with your values, run WarpSTR as follows: python WarpSTR.py example/config.yaml","title":"Overview"},{"location":"running_overview/#running-warpstr","text":"To run WarpSTR, first you must create a configuration file, that must adhere to YAML syntax. Check your input .fast5 and .bam files and populate the config accordingly (See Config section ). Also, you can change some advanced parameters, for that see Advanced parameters section ). Then, running WarpSTR is simple as it requires only the path to the config file. You can run WarpSTR for as many loci as you want, but all the information must be in the config. See example/config.yaml for an example of config file. After populating the config file with your values, run WarpSTR as follows: python WarpSTR.py example/config.yaml","title":"Running WarpSTR"}]}